---
title: "快速入门指南"
description: "几分钟内启用 MemMachine 的个性化记忆"
icon: "circle-play"
---

## 安装

最快体验 MemMachine 的方式是使用 Docker 与 Docker Compose。此方案将所有必需组件打包进容器之中，大幅简化部署流程。

### 前置条件

在安装 MemMachine 之前，请确认已经准备好以下环境：

- **Python 3.12+**：MemMachine 需要 Python 3.12 或更高版本
- **OpenAI API Key**：用于大语言模型与向量嵌入
<Note>MemMachine 本身可免费安装，但在使用软件时会消耗对应模型的 tokens。</Note>

### 下载并启动 MemMachine
此方法适用于绝大多数用户。
<Steps>
  <Step title="安装 Docker 与 Docker Compose">
      请确保你的机器已安装 [Docker](https://docs.docker.com/engine/install/) 与 [Docker Compose](https://docs.docker.com/compose/install/)。
  </Step>
  <Step title="下载 MemMachine 并运行脚本">
      <Tabs>
        <Tab title="Windows" icon="windows">
          如果你使用的是 Windows，可直接在 PowerShell 中运行以下命令；若在 WSL 环境，请参考 Linux 选项卡。
          ```powershell
          # One-block install for Windows PowerShell
          $latestRelease = Invoke-RestMethod -Uri "https://api.github.com/repos/MemMachine/MemMachine/releases/latest"; `
          $tarballUrl = $latestRelease.tarball_url; `
          $destination = "MemMachine"; `
          if (Test-Path $destination) { Remove-Item $destination -Recurse -Force }; `
          New-Item -ItemType Directory -Force -Path $destination; `
          Invoke-WebRequest -Uri $tarballUrl -OutFile "MemMachine-latest.tar.gz"; `
          tar -xzf "MemMachine-latest.tar.gz" -C $destination --strip-components=1; `
          Set-Location $destination; `
          ./memmachine-compose.sh
          ```
        </Tab>
        <Tab title="MacOS" icon="apple">
          如果你使用的是 macOS，可在终端（Terminal）中执行以下命令。
          ```bash
          # Download the latest release tarball
          curl -s https://api.github.com/repos/MemMachine/MemMachine/releases/latest \
            | grep "tarball_url" \
            | cut -d '"' -f 4 \
            | xargs curl -L -o MemMachine-latest.tar.gz

          # Extract the release
          tar -xzf MemMachine-latest.tar.gz

          # Enter the folder (GitHub adds a hash to the folder name)
          cd MemMachine-MemMachine-*

          # Run the setup
          ./memmachine-compose.sh
          ```
        </Tab>
        <Tab title="Linux" icon="linux">
          如果你使用的是 Linux，可在终端中运行如下命令。
          ```bash
          # Download the latest release tarball
          curl -s https://api.github.com/repos/MemMachine/MemMachine/releases/latest \
            | grep "tarball_url" \
            | cut -d '"' -f 4 \
            | xargs curl -L -o MemMachine-latest.tar.gz

          # Extract the release
          tar -xzf MemMachine-latest.tar.gz

          # Enter the folder (GitHub adds a hash to the folder name)
          cd MemMachine-MemMachine-*

          # Run the setup
          ./memmachine-compose.sh
          ```
          
        </Tab>
      </Tabs>

      就这样！脚本会带你完成剩余流程，并自动检测 MemMachine 的安装与配置是否正常。        
  </Step>
  <Step title="了解 memmachine-compose.sh 脚本">
    `memmachine-compose.sh` 不仅能安装 MemMachine（这也是它的默认行为），还支持停止、重启、查看日志以及清理环境等多种操作，如下所示：
    ```sh
      ./memmachine-compose.sh --help
        MemMachine Docker Startup Script

        Usage: ./memmachine-compose.sh [command]

        Commands:
          (no args) | start [<image>:<tag>]                      Start MemMachine services
          stop                                                   Stop MemMachine services
          restart                                                Restart MemMachine services
          logs                                                   Show service logs
          clean                                                  Remove all services and data
          build [<image>:<tag>] [--gpu true/false] [-f|--force]  Build a custom MemMachine image
          help                                                   Show this help message
    ```
  </Step>
</Steps>

### Hello World 示例
通过以下示例确认安装是否成功。每个示例都会展示如何在不同接口（RESTful API、MCP Server 与 Python SDK）中添加、搜索、删除记忆片段。

<Tabs>
  <Tab title="RESTful API" icon="server">
    ### Hello World：MemMachine RESTful API 指南

本指南将通过 `curl` 命令，带你快速上手 MemMachine 的 RESTful API。

### 前置条件

首先，请确保 FastAPI 应用已经启动。在终端中定位到包含 `app.py` 的目录，执行以下命令，看到服务监听输出后即可继续。

```
uvicorn app:app --reload
```
<Steps>
<Step title="获取所有会话">

最简单的检查方式是直接列出当前会话。此 `GET` 请求无需携带数据，因为尚未创建会话，所以通常会返回空列表。

```
curl http://127.0.0.1:8080/v1/sessions
```
</Step>
<Step title="新增记忆片段">

接下来，创建你的第一个记忆片段。`POST /v1/memories` 端点需要一个 JSON 请求体，包含会话信息、生产者、接收者以及记忆内容。

**Command:**

```
curl -X POST "http://127.0.0.1:8080/v1/memories" \
-H "Content-Type: application/json" \
-d '{
  "session": {
    "group_id": "test_group",
    "agent_id": ["test_agent"],
    "user_id": ["test_user"],
    "session_id": "session_123"
  },
  "producer": "test_user",
  "produced_for": "test_agent",
  "episode_content": "This is a simple test memory.",
  "episode_type": "message",
  "metadata": {}
}'
```

**预期结果：**

你会收到空的 `200 OK` 响应，表示记忆已成功写入。
</Step>
<Step title="检索记忆片段">

在成功写入之后，我们尝试搜索它。`POST /v1/memories/search` 端点同样需要 JSON 请求体，用于携带查询条件与会话信息。

**Command:**

```
curl -X POST "http://127.0.0.1:8080/v1/memories/search" \
-H "Content-Type: application/json" \
-d '{
  "session": {
    "group_id": "test_group",
    "agent_id": ["test_agent"],
    "user_id": ["test_user"],
    "session_id": "session_123"
  },
  "query": "simple test memory",
  "filter": {},
  "limit": 5
}'
```

**预期结果：**

你将获得 `200 OK` 响应，JSON 结果中会包含刚刚创建的记忆片段，确认检索成功。
</Step>
<Step title="删除会话数据">

测试完成后，可通过 `DELETE /v1/memories` 清理对应会话的数据，同样需要在请求体中指定目标会话。

**Command:**

```
curl -X DELETE "http://127.0.0.1:8080/v1/memories" \
-H "Content-Type: application/json" \
-d '{
  "session": {
    "group_id": "test_group",
    "agent_id": ["test_agent"],
    "user_id": ["test_user"],
    "session_id": "session_123"
  }
}'
```
</Step>
</Steps>
  </Tab>
  <Tab title="MCP Server" icon="terminal">
    ### Hello World：MemMachine MCP Server API 指南

本指南同样使用 `curl` 命令，帮助你快速体验 MemMachine 的 Model Content Protocol (MCP) Server API。

### 前置条件

首先确保 FastAPI 应用正在运行。在终端中进入 `app.py` 所在目录，执行以下命令，确认服务已启动。

```
uvicorn app:app --reload
```
<Steps>
<Step title="获取所有会话">

最简单的起点依旧是查看当前会话。这是一个 MCP **resource**，会返回所有可用会话的列表。

**Command:**

```
curl http://127.0.0.1:8080/v1/mcp/sessions
```

**预期结果：**

若尚未创建会话，通常会看到空列表。
</Step>
<Step title="新增记忆片段">

这里我们会使用 MCP 的 **tool** 来创建第一个记忆片段。`/v1/mcp/add_session_memory` 通过 `POST` 请求调用。

**Command:**

```
curl --request POST \
  --url http://localhost:8080/v1/mcp/add_session_memory \
  --header 'Content-Type: application/json' \
  --data '{
  "session": {
    "group_id": "<string>",
    "agent_id": [
      "<string>"
    ],
    "user_id": [
      "<string>"
    ],
    "session_id": "<string>"
  },
  "producer": "<string>",
  "produced_for": "<string>",
  "episode_content": "<string>",
  "episode_type": "<string>",
  "metadata": {}
}'
```

**预期结果：**

你将收到一个 JSON 响应，其中 `status` 为 `0` 表示成功。

```
{
  "status": 0,
  "error_msg": ""
}
```
</Step>
<Step title="检索记忆片段">

写入记忆后，我们使用 `/v1/mcp/search_session_memory` **tool** 进行检索。

**Command:**

```
curl --request POST \
  --url http://localhost:8080/v1/mcp/search_session_memory \
  --header 'Content-Type: application/json' \
  --data '{
  "session": {
    "group_id": "<string>",
    "agent_id": [
      "<string>"
    ],
    "user_id": [
      "<string>"
    ],
    "session_id": "<string>"
  },
  "query": "<string>",
  "filter": {},
  "limit": 123
}'
```

**预期结果：**

你将看到 `200 OK` 响应以及包含刚才创建的记忆片段的查询结果。
</Step>
<Step title="删除会话数据">

测试结束后，可通过 `/v1/mcp/delete_session_data` **tool** 清理会话数据，让数据库保持整洁。

**Command:**

```
curl --request POST \
  --url http://localhost:8080/v1/mcp/delete_session_data \
  --header 'Content-Type: application/json' \
  --data '{
  "session": {
    "group_id": "<string>",
    "agent_id": [
      "<string>"
    ],
    "user_id": [
      "<string>"
    ],
    "session_id": "<string>"
  }
}'
```

**预期结果：**

返回的 JSON 会告知删除状态，`status` 为 `0` 表示数据已成功删除。

```
{
  "status": 0,
  "error_msg": ""
}
```
</Step>
</Steps>
  </Tab>
  <Tab title="PythonSDK" icon="python">
    下方提供一段简短的 Python 脚本，演示如何通过 MemMachine Python SDK 同时使用情景记忆与画像记忆。

    <Note>如果你采用 Docker Compose 之外的部署方式，请按照 [安装指南](./install_guide.mdx) 配置 `cfg.yml` 文件。</Note>
    
  ```python HelloWorld.py expandable
    from dotenv import load_dotenv
    import os
    from importlib import import_module

    from memmachine.common.embedder.openai_embedder import OpenAIEmbedder
    from memmachine.common.language_model.openai_language_model import (
      OpenAILanguageModel,
    )
    from memmachine.episodic_memory.data_types import ContentType
    from memmachine.episodic_memory.episodic_memory import (
      AsyncEpisodicMemory,
      EpisodicMemory,
    )
    from memmachine.episodic_memory.episodic_memory_manager import (
      EpisodicMemoryManager,
    )
    from memmachine.profile_memory.profile_memory import ProfileMemory

    async def episodic_memory_test(config_path: str):
      manager = EpisodicMemoryManager.create_episodic_memory_manager(config_path)
      inst: EpisodicMemory = await manager.get_episodic_memory_instance(
          group_id="test_group",
          agent_id=["test_agent"],
          user_id=["test_user1", "test_user2"],
          session_id="test_session",
      )
      async with AsyncEpisodicMemory(inst) as inst:
          success = await inst.add_memory_episode(
              producer="test_user1",
              produced_for="test_user2",
              episode_content="test_content",
              episode_type="test_type",
              content_type=ContentType.STRING
          )
          print(success)
          success = await inst.add_memory_episode(
            producer="test_user2",
            produced_for="test_user1",
            episode_content="test_content2",
            episode_type="test_type",
            content_type=ContentType.STRING
        )
        print(success)
        res = await inst.query_memory("test_query")
        print(res)

        usr_filter = {"producer": "test_user1"}
        res = await inst.query_memory("test_query", filter=usr_filter)
        print(res)

  async def profile_memory_test():
    load_dotenv()
    api_key = os.getenv("OPENAI_API_KEY")
    model_name = "gpt-4.1-mini"
    llm_model = OpenAILanguageModel({"api_key": api_key, "model": model_name})
    embeddings = OpenAIEmbedder({"api_key": api_key})
    profile_memory = ProfileMemory(
        model=llm_model,
        embeddings=embeddings,
        db_config={
            "host": os.getenv("POSTGRES_HOST"),
            "port": os.getenv("POSTGRES_PORT"),
            "user": os.getenv("POSTGRES_USER"),
            "password": os.getenv("POSTGRES_PASSWORD"),
            "database": os.getenv("POSTGRES_DB"),
        },
        prompt_module=import_module(".prompt.profile_prompt", __package__),
    )
    await profile_memory.add_persona_message(
            str("Persona message"),
            {},
            user_id="user1",
        )
    
    await profile_memory.semantic_search("test_query", user_id="user1")



  async def main():
    await episodic_memory_test("cfg.yml")
    await profile_memory_test()

  if __name__ == "__main__":
    import asyncio
    asyncio.run(main())

    ```

    将脚本保存至当前目录后，执行以下命令查看输出：
    ```bash
    python3 ./HelloWorld.py
    ```
  </Tab>
</Tabs>

### 故障排查

#### 常见问题

1. **配置文件命名**：早期版本的 Docker Compose 配置文件名为 `configuration.yml`，目前仍然兼容，但推荐使用 `cfg.yml`。
2. **Neo4j 连接错误**：请确保 `cfg.yml` 中的 Neo4j 主机配置为 `memmachine-neo4j-custom`（而非 `localhost`）。
3. **OpenAI API Key 错误**：确认 `cfg.yml` 中配置了有效的 OpenAI API Key。
4. **端口访问问题**：若无法访问 API，请确认 MemMachine 容器运行在 `memmachine-network` 网络上，并且 8080 端口可用。
5. **容器网络问题**：确保所有相关容器均在同一 Docker 网络（`memmachine-network`）中。

#### 常用命令

- 查看容器状态：`docker ps`
- 查看容器日志：`docker logs <container_id>`
- 停止容器：`docker stop <container_id>`
- 删除容器：`docker rm <container_id>`
